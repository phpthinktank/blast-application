<?php
/**
 * Created by PhpStorm.
 * User: Marco Bunge
 * Date: 04.11.2015
 * Time: 14:34
 */

namespace Blasts\Tests;


use Blast\Application\Kernel\Foundation as Application;
use Blast\Application\Kernel\KernelInterface;
use Blast\Application\Strategy\StrategyInterface;
use Interop\Container\ContainerInterface;
use Prophecy\Argument;
use Prophecy\Prophecy\ObjectProphecy;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;

class ApplicationTest extends \PHPUnit_Framework_TestCase
{

    /**
     * @var ObjectProphecy
     */
    private $request;

    /**
     * @var ObjectProphecy
     */
    private $response;

    /**
     * @var ObjectProphecy
     */
    private $strategy;

    /**
     * @var ObjectProphecy
     */
    private $container;

    protected function setUp()
    {
        parent::setUp(); // TODO: Change the autogenerated stub

        //prepare container
        $this->container = $this->prophesize(ContainerInterface::class);
        $this->container->willImplement(ContainerInterface::class);

        //prepare response
        $this->response = $this->prophesize(ResponseInterface::class);
        $this->response->willImplement(ResponseInterface::class);

        //prepare request
        $this->request = $this->prophesize(ServerRequestInterface::class);
        $this->request->willImplement(ServerRequestInterface::class);
        $this->request->withAttribute(Argument::cetera())->willReturn($this->request->reveal());

        //prepare startegy
        $this->strategy = $this->prophesize(StrategyInterface::class);
        $this->strategy->willImplement(StrategyInterface::class);
        $this->strategy->dispatch(Argument::type(KernelInterface::class), Argument::type(ServerRequestInterface::class), Argument::type(ResponseInterface::class))
            ->will(function($args){
                //response is last argument
                //we just set pointer to the end...
                end($args);

                //... and return Response
                return current($args);

            });
    }
    
    /**
     * Assert that dispatch is executng attached strategy and returning response
     * Assert that added strategy is instance of StrategyInterface and is receivable
     */
    public function testApplicationDispatching()
    {
        $request = $this->request->reveal();
        $response = $this->response->reveal();

        $application = new Application();
        $application->setStrategy($this->strategy->reveal());
        $this->assertInstanceOf(StrategyInterface::class, $application->getStrategy());
        $this->assertInstanceOf(ResponseInterface::class, $application->dispatch($request, $response));
    }

    /**
     * Assert that added container is instance of ContainerInterface and is receivable
     */
    public function testSetContainer()
    {
        $application = new Application();
        $application->setContainer($this->container->reveal());
        $this->assertInstanceOf(ContainerInterface::class, $application->getContainer());
    }

    /**
     * Assert that added config is an array and is receivable
     */
    public function testSetConfig()
    {
        $application = new Application();
        $application->setConfig([]);
        $this->assertInternalType('array', $application->getConfig());
    }

    /**
     * Assert that added config objects can be cast to an array is an array and is receivable
     */
    public function testSetConfigArrayCasting()
    {
        $application = new Application();
        $application->setConfig((array) new \ArrayObject());
        $this->assertInternalType('array', $application->getConfig());

        $application->setConfig((array) new \stdClass());
        $this->assertInternalType('array', $application->getConfig());
    }
}
